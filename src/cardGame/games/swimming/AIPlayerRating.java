package cardGame.games.swimming;

import cardGame.card.CardDeck;
import cardGame.util.Util;

/**
 * Collection of <code>CardStack</code> related rating functions. This class is
 * tight tied to the <code>AIPlayer</code> by sharing objects of it.<br/>
 * 
 * All <code>rate*()</code> functions are chain-able together. For this reason
 * the return a reference to this class. Their rating results are recorded in an
 * separate {@link Rating} object.
 */
public class AIPlayerRating {
    /** Cards probably wanted by the player. */
    private final CardStack playerWantedCards;
    /** Cards currently owned by the player. */
    private final CardStack playerCards;
    /** Cards currently available on the table. */
    private final CardStack tableCards;
    /** Cards seen by the player (card dropped to the table). */
    private final CardStack seenCards;

    /** Maximum value a card rating by type may reach. */
    // TODO: set real values
    protected static final int WORTH_MAX_BY_TYPE = 127;
    /** Maximum value a card rating by color may reach. */

    /** How many cards of a type/color are needed. */
    private static final byte RULE_CARDS_TO_WIN = 3;

    // TODO: this is ugly!
    public static final int AVAILABILITY_UNSEEN = -5;

    /** Multiple ratings result storage. */
    private final Rating ratingStore = new Rating();

    /**
     * Creates a new <code>Card</code> rating object.
     * 
     * @param playerCardStack
     *            The CardStack with cards currently owned by the player.
     * @param wantedCardStack
     *            The CardStack with cards wanted by the player. This CardStack
     *            will be updated with the proper priority values. The higher a
     *            value the more the player wants this card. The
     *            <code>CardStack</code> should be pre-filled with values
     *            generated by {@link AIPlayerRateStack#calculateWantedCards()}
     * @param tableCardStack
     *            The cards currently available on the table
     * @param seenCardStack
     *            Cards seen by the player
     */
    AIPlayerRating(final CardStack playerCardStack,
	    final CardStack wantedCardStack, final CardStack tableCardStack,
	    final CardStack seenCardStack) {
	// shared objects
	this.playerWantedCards = wantedCardStack;
	this.playerCards = playerCardStack;
	this.tableCards = tableCardStack;
	this.seenCards = seenCardStack;
    }

    /** Helper class to record multiple ratings in one place. */
    private class Rating {
	/** The overall rating value. */
	private float ratingValue;
	/** Number of ratings recorded by this object. */
	private byte ratingCount;

	/** Create a new object to record multiple ratings. */
	Rating() {
	    this.clear();
	}

	/** Clear all previous recorded ratings. */
	void clear() {
	    this.ratingValue = 0;
	    this.ratingCount = 0;
	}

	/**
	 * Add a value to the overall rating.
	 * 
	 * @param min
	 *            Minimum value the rating can reach
	 * @param max
	 *            Maximum value the rating can reach
	 * @param value
	 *            Value to add
	 */
	void add(final float min, final float max, final float value) {
	    this.ratingCount++;
	    this.ratingValue += Util.normalize(min, max, value);
	}

	/**
	 * Get the average rating value for all recorded ratings.
	 * 
	 * @return Average rating value
	 */
	float avg() {
	    return this.ratingValue / this.ratingCount;
	}
    }

    /**
     * Rate a <code>Card</code> by it's probability to be in the game. This
     * means, if we have seen a card dropped on the table there's a possibility
     * to get this single card to complete our stack.
     * 
     * @param cardToRate
     *            Card to rate
     * @return <code>AIPlayerRating</code> for chaining
     */
    public final AIPlayerRating rateCardAvailability(
	    final CardDeck.Card cardToRate) {
	// Bounds are the unavailable card and the available. Legal values in
	// between may be assigned by the player.
	this.ratingStore.add(CardStack.CARD_UNAVAILABLE,
		Table.getCardValue(CardDeck.Card.CLUB_ACE),
		CardStack.CARD_AVAILABLE);
	return this;
    }

    /**
     * Update a rating array for all currently not-owned cards. This may be
     * helpful to decide, witch card to pick from the table. This will reset the
     * wanted cards stack at first.
     * 
     * This will rate all cards based on the ones owned by the player,
     * regardless of the ones currently available on the table. It's meant as
     * starting point for subsequent ratings.
     */
    public final void calculateWantedCards() {
	CardDeck.Color cardColor;
	CardDeck.Type cardType;
	int cardColorCount;
	int cardTypeCount;

	// remove previous value assignments
	this.playerWantedCards.resetCardValues();

	// go through all cards passed in as array
	for (CardDeck.Card ownedCard : this.playerCards.getCards()) {
	    // check color
	    cardColor = ownedCard.getColor();
	    cardColorCount = 0;
	    // count color occurrence of these cards
	    for (CardDeck.Card cardToCheck : this.playerCards.getCards()) {
		if (cardToCheck.getColor().equals(cardColor)) {
		    cardColorCount++;
		}
	    }
	    // do we have redundant colors?
	    for (CardDeck.Card colorCard : CardDeck.Deck.SKAT
		    .getCardsByColor(cardColor)) {
		// up-rate cards of the color we have just found
		// TODO: make rating changeable
		this.playerWantedCards
			.addToCardValue(colorCard,
				(byte) (cardColorCount * Table
					.getCardValue(colorCard)));
	    }
	    cardType = ownedCard.getType();
	    cardTypeCount = 0;
	    for (CardDeck.Card cardToCheck : this.playerCards.getCards()) {
		if (cardToCheck.getType().equals(cardType)) {
		    cardTypeCount++;
		}
	    }
	    // do we have redundant types?
	    for (CardDeck.Card typeCard : CardDeck.Deck.SKAT
		    .getCardsByType(cardType)) {
		// up-rate cards of the type we have just found
		// TODO: make rating changeable
		this.playerWantedCards.addToCardValue(typeCard,
			(byte) (cardTypeCount * Table.getCardValue(typeCard)));
	    }
	}
    }

    /**
     * Get the possible minimum- and maximum-value for a reachable color goal
     * state.
     * 
     * @param color
     *            Color witch will lead to a goal state
     * @return Array with minimum- and maximum-value
     */
    public final byte[] goalValue(final CardDeck.Color color) {
	byte[] goalValue = new byte[2];
	// gather current owned cards by color and calculate their current value
	for (CardDeck.Card card : this.playerCards.getCards()) {
	    if (card.getColor().equals(color)) {
		goalValue[0] += (byte) Table.getCardValue(card);
	    }
	}
	// set the base value
	goalValue[1] = goalValue[0];
	// add the lowest missing card, to get the minimum-value
	for (CardDeck.Card card : CardDeck.Deck.SKAT.getCardsByColor(color)) {
	    if (!this.playerCards.containsCard(card)) {
		goalValue[0] += Table.getCardValue(card);
		break;
	    }
	}
	// add the highest missing card, to get the maximum-value
	CardDeck.Card card;
	for (int i = CardDeck.Deck.SKAT.getCardsByColor(color).size() - 1; i > 0; i--) {
	    card = CardDeck.Deck.SKAT.getCardsByColor(color).get(i);
	    if (!this.playerCards.containsCard(card)) {
		goalValue[1] += Table.getCardValue(card);
		break;
	    }
	}
	return goalValue;
    }

    /**
     * Check, how many cards are missing to reach a goal state. No calculation
     * of values is involved here.
     * 
     * @return How many cards are missing to reach a goal state
     *         [color][steps][type][steps]
     */
    public final Object[] goalDistance() {
	// card color
	CardDeck.Color cardColor = null;
	// number of cards by a color
	Integer cardColorCount = null;
	// card type
	CardDeck.Type cardType = null;
	// number of cards by type
	Integer cardTypeCount = null;
	// general counters
	int count;
	// return object
	Object[] distances = new Object[4];

	for (CardDeck.Card card : this.playerCards.getCards()) {
	    // check card color
	    count = 0;
	    for (CardDeck.Card cardByColor : CardDeck.Deck.SKAT
		    .getCardsByColor(card.getColor())) {
		if (this.playerCards.containsCard(cardByColor)) {
		    count++;
		}
	    }
	    // store max
	    if ((cardColorCount == null) || (count > cardColorCount)) {
		cardColorCount = count;
		cardColor = card.getColor();
	    }

	    // check card type
	    count = 0;
	    for (CardDeck.Card cardByType : CardDeck.Deck.SKAT
		    .getCardsByType(card.getType())) {
		if (this.playerCards.containsCard(cardByType)) {
		    count++;
		}
	    }
	    // store max
	    if ((cardTypeCount == null) || (count > cardTypeCount)) {
		cardTypeCount = count;
		cardType = card.getType();
	    }
	}

	// check for possible near-goal states (one card missing)
	if (cardColorCount >= 2) {
	    distances[0] = cardColor;
	    distances[1] =
		    (CardDeck.Deck.SKAT.numberOfColors() - 1) - cardColorCount;
	}
	if (cardTypeCount >= 2) {
	    distances[2] = cardType;
	    distances[3] = RULE_CARDS_TO_WIN - cardTypeCount;
	}
	return distances;
    }

    /**
     * Suggest a semi-random card to pick. Makes a suggestion based on the cards
     * already seen by the player.
     * 
     * @return A <code>Card</code> selected from the ones on the table
     */
    final CardDeck.Card suggestRandomPick() {
	byte cardValue = 0;
	CardDeck.Card suggestedCard = null;
	// for now just pick the highest one
	for (CardDeck.Card card : this.tableCards.getCards()) {
	    if (Table.getCardValue(card) > cardValue) {
		cardValue = (byte) Table.getCardValue(card);
		suggestedCard = card;
	    }
	}
	return suggestedCard;
    }
}
